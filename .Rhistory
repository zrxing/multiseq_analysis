y = rpois(1024, 100)
est = ashsmooth.pois(y)
plot(est,type='l', ylim=c(0.5, 1.5))
plot(est,type='l', ylim=c(90, 110))
y = rpois(1024, 100)
est = ashsmooth.pois(y)
plot(est,type='l', ylim=c(90, 110))
y = rpois(1024, 100)
est = ashsmooth.pois(y)
plot(est,type='l', ylim=c(90, 110))
y = rpois(1024, 1)
set.seed(513)
y = rpois(1024, 1)
ParentTItable
smash::ParentTItable
smash:::ParentTItable
ashsmooth.pois
getlist.res
smash:::getlist.res
set.seed(513)
y = rpois(n, 1)
wc = as.vector(t(smash:::ParentTItable(y)$parent))
zdat = glm.approx(wc, g = NULL, minobs = 1, pseudocounts = 0.5,
center = FALSE, all = TRUE, forcebin = TRUE, repara = TRUE,
lm.approx = TRUE, disp = "add", bound = 0.02)
j = 1
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
n = 1024
J = 10
set.seed(513)
y = rpois(n, 1)
wc = as.vector(t(smash:::ParentTItable(y)$parent))
zdat = glm.approx(wc, g = NULL, minobs = 1, pseudocounts = 0.5,
center = FALSE, all = TRUE, forcebin = TRUE, repara = TRUE,
lm.approx = TRUE, disp = "add", bound = 0.02)
j = 1
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
hist(bhat/shat)
hist(bhat/shat,breaks=100)
j = 2
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
hist(bhat/shat, breaks = 100)
j = 3
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
hist(bhat/shat, breaks = 100)
j = 4
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
hist(bhat/shat, breaks = 100)
j = 4
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
hist(bhat/shat, breaks = 100)
j = 5
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
hist(bhat/shat, breaks = 100)
j = 8
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
hist(bhat/shat, breaks = 100)
j = 10
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
hist(bhat/shat, breaks = 100)
j = 7
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
hist(bhat/shat, breaks = 100)
hist(bhat/shat, breaks = 100, freq = FALSE)
lines(dnorm(seq(-4, 4, 0.01)))
dnorm(seq(-4, 4, 0.01))
hist(bhat/shat, breaks = 100, freq = FALSE)
lines(dnorm(seq(-4, 4, 0.01)))
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)))
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 1
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
hist(bhat/shat, breaks = 100, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 2
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
hist(bhat/shat, breaks = 100, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 3
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
hist(bhat/shat, breaks = 100, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 4
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
hist(bhat/shat, breaks = 100, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 5
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
hist(bhat/shat, breaks = 100, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 6
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
hist(bhat/shat, breaks = 100, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 7
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
hist(bhat/shat, breaks = 100, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 8
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
hist(bhat/shat, breaks = 100, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 9
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[1, ind]
shat = zdat[2, ind]
hist(bhat/shat, breaks = 100, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
m = 40
y = rpois(m * n, 1)
wc = matrix(nrow = m, ncol = 2 * J * n); for(i in 1:nsimg){tt = smash:::ParentTItable(y[i, ]); wc[i, ] = as.vector(t(tt$parent))}
wc = matrix(nrow = m, ncol = 2 * J * n); for(i in 1:m){tt = smash:::ParentTItable(y[i, ]); wc[i, ] = as.vector(t(tt$parent))}
y = matrix(rpois(m * n, 1), nr = m, ncol = n)
wc = matrix(nrow = m, ncol = 2 * J * n); for(i in 1:m){tt = smash:::ParentTItable(y[i, ]); wc[i, ] = as.vector(t(tt$parent))}
ashsmooth.pois
zdat = glm.approx(wc, g = rep(0:1 , each = m/2), minobs = 1, pseudocounts = 0.5, center = FALSE, all = FALSE, forcebin = TRUE, repara = TRUE, lm.approx = TRUE, disp = "add")
j = 9
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[3, ind]
shat = zdat[4, ind]
hist(bhat/shat, breaks = 100, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 1
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[3, ind]
shat = zdat[4, ind]
hist(bhat/shat, breaks = 100, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
hist(bhat/shat, breaks = 40, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 2
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[3, ind]
shat = zdat[4, ind]
hist(bhat/shat, breaks = 40, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 3
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[3, ind]
shat = zdat[4, ind]
hist(bhat/shat, breaks = 40, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 4
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[3, ind]
shat = zdat[4, ind]
hist(bhat/shat, breaks = 40, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 5
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[3, ind]
shat = zdat[4, ind]
hist(bhat/shat, breaks = 40, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 8
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[3, ind]
shat = zdat[4, ind]
hist(bhat/shat, breaks = 40, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 9
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[3, ind]
shat = zdat[4, ind]
hist(bhat/shat, breaks = 40, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
m = 4
y = matrix(rpois(m * n, 1), nr = m, ncol = n)
wc = matrix(nrow = m, ncol = 2 * J * n); for(i in 1:m){tt = smash:::ParentTItable(y[i, ]); wc[i, ] = as.vector(t(tt$parent))}
zdat = glm.approx(wc, g = rep(0:1 , each = m/2), minobs = 1, pseudocounts = 0.5, center = FALSE, all = FALSE, forcebin = TRUE, repara = TRUE, lm.approx = TRUE, disp = "add")
j = 9
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[3, ind]
shat = zdat[4, ind]
hist(bhat/shat, breaks = 40, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 1
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[3, ind]
shat = zdat[4, ind]
hist(bhat/shat, breaks = 40, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 2
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[3, ind]
shat = zdat[4, ind]
hist(bhat/shat, breaks = 40, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
j = 3
ind = ((j - 1) * n + 1):(j * n)
bhat = zdat[3, ind]
shat = zdat[4, ind]
hist(bhat/shat, breaks = 40, freq = FALSE)
lines(seq(-4, 4, 0.01), dnorm(seq(-4, 4, 0.01)), col = 2)
top_eqtl
library(dplyr)
?sperad
?spread
library(tidyr)
?spread
27500*1.45
baseline=rep(0.01,1024)
effect=rep(0,1024)
effect[400:500]=log(2)
g=c(0,0,0,1,1,1,2,2,2,2,2)
logl=matrix(0,11,1024)
for(i in 1:11){
logl[i,]=baseline+g[i]*effect
}
plot(logl[1,])
plot(logl[3,])
plot(logl[5,])
plot(logl[10,])
simdata=rpois(11*1024,logl)
plot(simdata[1,])
simdata=matrix(rpois(11*1024,logl),11,1024)
simdata[1,]
plot(simdata[1,])
plot(simdata[6,])
plot(simdata[9,])
tt=multiseq(simdata,g,lm.approx=TRUE)
library(multiseq)
tt=multiseq(simdata,g,lm.approx=TRUE)
plot(tt$baseline.mean)
plot(tt$effect.mean)
plot(tt$effect.mean,type='l')
plot(tt$baseline.mean,type='l')
plot(exp(tt$baseline.mean),type='l')
plot(exp(tt$effect.mean),type='l')
tt=multiseq(simdata,g,lm.approx=FALSE)
plot(tt$baseline.mean,type='l')
tt=multiseq(simdata,g,center=TRUE)
plot(tt$baseline.mean,type='l')
tt=multiseq(simdata,g,center=FALSE)
plot(tt$baseline.mean,type='l')
tt=multiseq(simdata,g,center=TRUE,baseline="grp")
plot(tt$baseline.mean,type='l')
tt=multiseq(simdata,g,center=TRUE,baseline="inter")
plot(tt$baseline.mean,type='l')
tt=multiseq(simdata,g,repara=FALSE)
plot(tt$baseline.mean,type='l')
tt=multiseq(simdata,g,repara=TRUE)
plot(tt$baseline.mean,type='l')
g=c(0,0,0,1,1,1)
logl=matrix(0,6,1024)
for(i in 1:6){
logl[i,]=baseline+g[i]*effect
}
simdata=matrix(rpois(6*1024,logl),6,1024)
tt=multiseq(simdata,g,repara=TRUE)
plot(tt$baseline.mean,type='l')
tt=multiseq(simdata,g,lm.approx=FALSE)
plot(tt$baseline.mean,type='l')
tt=multiseq(simdata,g,lm.approx=TRUE)
plot(tt$baseline.mean,type='l')
log(0.01)
setwd("D:/Grad School/projects/multiseq_analysis")
load("D:/Grad School/projects/multiseq_analysis/results/ctcf_large/ctcf_large.RData")
prior.breaks = log(quantile(ccount.train,c(0,0.5,0.7,0.9,0.99,1))+1)
prior.breaks[length(prior.breaks)] = ceiling(prior.breaks[length(prior.breaks)])
names(prior.breaks) = NULL
ccount.prior.info = hist(log(ccount.train+1),breaks = prior.breaks, plot = FALSE)
#ccount.prior.val = ccount.prior.info$mids
#ccount.prior.val = prior.breaks[1:(length(prior.breaks)-1)]
lccount.train = log(ccount.train+1)
ccount.prior.val = 0
for(i in 1:(length(prior.breaks)-1)){
ccount.prior.val[i] = mean(lccount.train[lccount.train>=prior.breaks[i]&lccount.train<prior.breaks[i+1]])
}
#ccount.prior.prob = normalize(smooth.spline(ccount.prior.info$mids,ccount.prior.info$counts)$y)
ccount.prior.prob = normalize(ccount.prior.info$counts)
##computing the likelihood
lambda.for = exp(rep(1,length(ccount.prior.val))%o%base.mean.for + ccount.prior.val%o%eff.mean.for)
lambda.rev = exp(rep(1,length(ccount.prior.val))%o%base.mean.rev + ccount.prior.val%o%eff.mean.rev)
lik.for = matrix(0,length(ccount.test),length(ccount.prior.val))
lik.rev = matrix(0,length(ccount.test),length(ccount.prior.val))
for(i in 1:length(ccount.test)){
loglik.ini.for = rowSums(t(apply(lambda.for,1,dpois,x = as.numeric(dprof.test[i,1:nbase]),log = TRUE)))
loglik.ini.for = loglik.ini.for - max(loglik.ini.for)
loglik.ini.rev = rowSums(t(apply(lambda.rev,1,dpois,x = as.numeric(dprof.test[i,(nbase + 1):(2 * nbase)]),log = TRUE)))
loglik.ini.rev = loglik.ini.rev - max(loglik.ini.rev)
lik.for[i,] = exp(loglik.ini.for)
lik.rev[i,] = exp(loglik.ini.rev)
}
##computing the posterior
ccount.post.val = ccount.prior.val
ccount.post.prob.for = lik.for * (rep(1,length(ccount.test))%o%ccount.prior.prob)
ccount.post.prob.rev = lik.rev * (rep(1,length(ccount.test))%o%ccount.prior.prob)
ccount.post.prob.for = t(apply(ccount.post.prob.for,1,normalize))
ccount.post.prob.rev = t(apply(ccount.post.prob.rev,1,normalize))
ccount.post.mean.for = 0
ccount.post.class.for = 0
ccount.post.mean.rev = 0
ccount.post.class.rev = 0
for(i in 1:length(ccount.test)){
ccount.post.class.for[i] = which(ccount.post.prob.for[i,]==max(ccount.post.prob.for[i,]))
ccount.post.mean.for[i] = sum((ccount.post.val)*ccount.post.prob.for[i,])
ccount.post.class.rev[i] = which(ccount.post.prob.rev[i,]==max(ccount.post.prob.rev[i,]))
ccount.post.mean.rev[i] = sum((ccount.post.val)*ccount.post.prob.rev[i,])
}
ccount.test.m = log(ccount.test+1)
ccount.test.class = 0
for(i in 1:(length(prior.breaks)-1)){
ccount.test.class = ccount.test.class + i*(ccount.test.m>=prior.breaks[i]&ccount.test.m<prior.breaks[i+1])
}
ccount.post.meanclass.for = 0
for(i in 1:(length(prior.breaks)-1)){
ccount.post.meanclass.for = ccount.post.meanclass.for + i*(ccount.post.mean.for>=prior.breaks[i]&ccount.post.mean.for<prior.breaks[i+1])
}
res.multiclass=sum(ccount.post.class.for==ccount.test.class)/length(ccount.test.class)
res.multiclass
prior.breaks = log(quantile(ccount.train,c(0,0.6,1))+1)
prior.breaks[length(prior.breaks)] = ceiling(prior.breaks[length(prior.breaks)])
names(prior.breaks) = NULL
ccount.prior.info = hist(log(ccount.train+1),breaks = prior.breaks, plot = FALSE)
#ccount.prior.val = ccount.prior.info$mids
#ccount.prior.val = prior.breaks[1:(length(prior.breaks)-1)]
lccount.train = log(ccount.train+1)
ccount.prior.val = 0
for(i in 1:(length(prior.breaks)-1)){
ccount.prior.val[i] = mean(lccount.train[lccount.train>=prior.breaks[i]&lccount.train<prior.breaks[i+1]])
}
#ccount.prior.prob = normalize(smooth.spline(ccount.prior.info$mids,ccount.prior.info$counts)$y)
ccount.prior.prob = normalize(ccount.prior.info$counts)
##computing the likelihood
lambda.for = exp(rep(1,length(ccount.prior.val))%o%base.mean.for + ccount.prior.val%o%eff.mean.for)
lambda.rev = exp(rep(1,length(ccount.prior.val))%o%base.mean.rev + ccount.prior.val%o%eff.mean.rev)
lik.for = matrix(0,length(ccount.test),length(ccount.prior.val))
lik.rev = matrix(0,length(ccount.test),length(ccount.prior.val))
for(i in 1:length(ccount.test)){
loglik.ini.for = rowSums(t(apply(lambda.for,1,dpois,x = as.numeric(dprof.test[i,1:nbase]),log = TRUE)))
loglik.ini.for = loglik.ini.for - max(loglik.ini.for)
loglik.ini.rev = rowSums(t(apply(lambda.rev,1,dpois,x = as.numeric(dprof.test[i,(nbase + 1):(2 * nbase)]),log = TRUE)))
loglik.ini.rev = loglik.ini.rev - max(loglik.ini.rev)
lik.for[i,] = exp(loglik.ini.for)
lik.rev[i,] = exp(loglik.ini.rev)
}
##computing the posterior
ccount.post.val = ccount.prior.val
ccount.post.prob.for = lik.for * (rep(1,length(ccount.test))%o%ccount.prior.prob)
ccount.post.prob.rev = lik.rev * (rep(1,length(ccount.test))%o%ccount.prior.prob)
ccount.post.prob.for = t(apply(ccount.post.prob.for,1,normalize))
ccount.post.prob.rev = t(apply(ccount.post.prob.rev,1,normalize))
ccount.post.mean.for = 0
ccount.post.class.for = 0
ccount.post.mean.rev = 0
ccount.post.class.rev = 0
for(i in 1:length(ccount.test)){
ccount.post.class.for[i] = which(ccount.post.prob.for[i,]==max(ccount.post.prob.for[i,]))
ccount.post.mean.for[i] = sum((ccount.post.val)*ccount.post.prob.for[i,])
ccount.post.class.rev[i] = which(ccount.post.prob.rev[i,]==max(ccount.post.prob.rev[i,]))
ccount.post.mean.rev[i] = sum((ccount.post.val)*ccount.post.prob.rev[i,])
}
ccount.test.m = log(ccount.test+1)
ccount.test.class = 0
for(i in 1:(length(prior.breaks)-1)){
ccount.test.class = ccount.test.class + i*(ccount.test.m>=prior.breaks[i]&ccount.test.m<prior.breaks[i+1])
}
ccount.post.meanclass.for = 0
for(i in 1:(length(prior.breaks)-1)){
ccount.post.meanclass.for = ccount.post.meanclass.for + i*(ccount.post.mean.for>=prior.breaks[i]&ccount.post.mean.for<prior.breaks[i+1])
}
res.multiclass=sum(ccount.post.class.for==ccount.test.class)/length(ccount.test.class)
res.2class=sum(ccount.post.class.for==ccount.test.class)/length(ccount.test.class)
res.2class
prior.breaks = log(quantile(ccount.train,c(0,0.5,0.7,0.9,0.99,1))+1)
prior.breaks[length(prior.breaks)] = ceiling(prior.breaks[length(prior.breaks)])
names(prior.breaks) = NULL
ccount.prior.info = hist(log(ccount.train+1),breaks = prior.breaks, plot = FALSE)
#ccount.prior.val = ccount.prior.info$mids
#ccount.prior.val = prior.breaks[1:(length(prior.breaks)-1)]
lccount.train = log(ccount.train+1)
ccount.prior.val = 0
for(i in 1:(length(prior.breaks)-1)){
ccount.prior.val[i] = mean(lccount.train[lccount.train>=prior.breaks[i]&lccount.train<prior.breaks[i+1]])
}
#ccount.prior.prob = normalize(smooth.spline(ccount.prior.info$mids,ccount.prior.info$counts)$y)
ccount.prior.prob = normalize(ccount.prior.info$counts)
##computing the likelihood
lambda.for = exp(rep(1,length(ccount.prior.val))%o%base.mean.for + ccount.prior.val%o%eff.mean.for)
lambda.rev = exp(rep(1,length(ccount.prior.val))%o%base.mean.rev + ccount.prior.val%o%eff.mean.rev)
lik.for = matrix(0,length(ccount.test),length(ccount.prior.val))
lik.rev = matrix(0,length(ccount.test),length(ccount.prior.val))
for(i in 1:length(ccount.test)){
loglik.ini.for = rowSums(t(apply(lambda.for,1,dpois,x = as.numeric(dprof.test[i,1:nbase]),log = TRUE)))
loglik.ini.for = loglik.ini.for - max(loglik.ini.for)
loglik.ini.rev = rowSums(t(apply(lambda.rev,1,dpois,x = as.numeric(dprof.test[i,(nbase + 1):(2 * nbase)]),log = TRUE)))
loglik.ini.rev = loglik.ini.rev - max(loglik.ini.rev)
lik.for[i,] = exp(loglik.ini.for)
lik.rev[i,] = exp(loglik.ini.rev)
}
##computing the posterior
ccount.post.val = ccount.prior.val
ccount.post.prob.for = lik.for * (rep(1,length(ccount.test))%o%ccount.prior.prob)
ccount.post.prob.rev = lik.rev * (rep(1,length(ccount.test))%o%ccount.prior.prob)
ccount.post.prob.for = t(apply(ccount.post.prob.for,1,normalize))
ccount.post.prob.rev = t(apply(ccount.post.prob.rev,1,normalize))
ccount.post.mean.for = 0
ccount.post.class.for = 0
ccount.post.mean.rev = 0
ccount.post.class.rev = 0
for(i in 1:length(ccount.test)){
ccount.post.class.for[i] = which(ccount.post.prob.for[i,]==max(ccount.post.prob.for[i,]))
ccount.post.mean.for[i] = sum((ccount.post.val)*ccount.post.prob.for[i,])
ccount.post.class.rev[i] = which(ccount.post.prob.rev[i,]==max(ccount.post.prob.rev[i,]))
ccount.post.mean.rev[i] = sum((ccount.post.val)*ccount.post.prob.rev[i,])
}
ccount.test.m = log(ccount.test+1)
ccount.test.class = 0
for(i in 1:(length(prior.breaks)-1)){
ccount.test.class = ccount.test.class + i*(ccount.test.m>=prior.breaks[i]&ccount.test.m<prior.breaks[i+1])
}
ccount.post.meanclass.for = 0
for(i in 1:(length(prior.breaks)-1)){
ccount.post.meanclass.for = ccount.post.meanclass.for + i*(ccount.post.mean.for>=prior.breaks[i]&ccount.post.mean.for<prior.breaks[i+1])
}
res.multiclass=sum(ccount.post.class.for==ccount.test.class)/length(ccount.test.class)
res.multiclass
res.2class
res.multiclass
res.2class
prior.breaks
log(quantile(ccount.train,c(0,0.6,1))+1)
log(quantile(ccount.train,c(0,0.5,1))+1)
prior.breaks = log(quantile(ccount.train,c(0,0.5,1))+1)
prior.breaks[length(prior.breaks)] = ceiling(prior.breaks[length(prior.breaks)])
names(prior.breaks) = NULL
ccount.prior.info = hist(log(ccount.train+1),breaks = prior.breaks, plot = FALSE)
#ccount.prior.val = ccount.prior.info$mids
#ccount.prior.val = prior.breaks[1:(length(prior.breaks)-1)]
lccount.train = log(ccount.train+1)
ccount.prior.val = 0
for(i in 1:(length(prior.breaks)-1)){
ccount.prior.val[i] = mean(lccount.train[lccount.train>=prior.breaks[i]&lccount.train<prior.breaks[i+1]])
}
#ccount.prior.prob = normalize(smooth.spline(ccount.prior.info$mids,ccount.prior.info$counts)$y)
ccount.prior.prob = normalize(ccount.prior.info$counts)
##computing the likelihood
lambda.for = exp(rep(1,length(ccount.prior.val))%o%base.mean.for + ccount.prior.val%o%eff.mean.for)
lambda.rev = exp(rep(1,length(ccount.prior.val))%o%base.mean.rev + ccount.prior.val%o%eff.mean.rev)
lik.for = matrix(0,length(ccount.test),length(ccount.prior.val))
lik.rev = matrix(0,length(ccount.test),length(ccount.prior.val))
for(i in 1:length(ccount.test)){
loglik.ini.for = rowSums(t(apply(lambda.for,1,dpois,x = as.numeric(dprof.test[i,1:nbase]),log = TRUE)))
loglik.ini.for = loglik.ini.for - max(loglik.ini.for)
loglik.ini.rev = rowSums(t(apply(lambda.rev,1,dpois,x = as.numeric(dprof.test[i,(nbase + 1):(2 * nbase)]),log = TRUE)))
loglik.ini.rev = loglik.ini.rev - max(loglik.ini.rev)
lik.for[i,] = exp(loglik.ini.for)
lik.rev[i,] = exp(loglik.ini.rev)
}
##computing the posterior
ccount.post.val = ccount.prior.val
ccount.post.prob.for = lik.for * (rep(1,length(ccount.test))%o%ccount.prior.prob)
ccount.post.prob.rev = lik.rev * (rep(1,length(ccount.test))%o%ccount.prior.prob)
ccount.post.prob.for = t(apply(ccount.post.prob.for,1,normalize))
ccount.post.prob.rev = t(apply(ccount.post.prob.rev,1,normalize))
ccount.post.mean.for = 0
ccount.post.class.for = 0
ccount.post.mean.rev = 0
ccount.post.class.rev = 0
for(i in 1:length(ccount.test)){
ccount.post.class.for[i] = which(ccount.post.prob.for[i,]==max(ccount.post.prob.for[i,]))
ccount.post.mean.for[i] = sum((ccount.post.val)*ccount.post.prob.for[i,])
ccount.post.class.rev[i] = which(ccount.post.prob.rev[i,]==max(ccount.post.prob.rev[i,]))
ccount.post.mean.rev[i] = sum((ccount.post.val)*ccount.post.prob.rev[i,])
}
ccount.test.m = log(ccount.test+1)
ccount.test.class = 0
for(i in 1:(length(prior.breaks)-1)){
ccount.test.class = ccount.test.class + i*(ccount.test.m>=prior.breaks[i]&ccount.test.m<prior.breaks[i+1])
}
ccount.post.meanclass.for = 0
for(i in 1:(length(prior.breaks)-1)){
ccount.post.meanclass.for = ccount.post.meanclass.for + i*(ccount.post.mean.for>=prior.breaks[i]&ccount.post.mean.for<prior.breaks[i+1])
}
res.2class=sum(ccount.post.class.for==ccount.test.class)/length(ccount.test.class)
